using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;

namespace SunGiant.Framework.Ophelia.Cameras
{
    public class RTSCamBehavior
        : Behavior
    {
        CameraSubject mSubject = null;
        public void SetCameraSubject(CameraSubject zSub) { mSubject = zSub; }

        const float mTranslationSpeed = 100.0f;

        // The amount of time it takes to zoom right in with the triggers
        const float timeToZoomIn = 2.0f;

        float zoomFraction = 0.7f;


        public float minPitch = -20.0f;
        public float maxPitch = -60.0f;

        public float minHeight = 30.0f;
        public float maxHeight = 150.0f;


        Vector3 translation;
        float rotationSpeed = Maths.Euclid.PI / 2.0f;
        float yaw = 0.0f;

        Ray ray = new Ray();
        Plane xz = new Plane();

        void WorkOutTranslation(float zDt)
        {
            if (Sys.Input.KeyboardKeyPressed(Keys.W))
                translation.Z = -zDt * mTranslationSpeed;
            else if (Sys.Input.KeyboardKeyPressed(Keys.S))
                translation.Z = zDt * mTranslationSpeed;
            else
                translation.Z = zDt * mTranslationSpeed * -Sys.Input.GamePad.ThumbSticks.Right.Y;


            if (Sys.Input.KeyboardKeyPressed(Keys.D))
                translation.X = zDt * mTranslationSpeed;
            else if (Sys.Input.KeyboardKeyPressed(Keys.A))
                translation.X = -zDt * mTranslationSpeed;
            else
                translation.X = zDt * mTranslationSpeed * Sys.Input.GamePad.ThumbSticks.Right.X;


            // work out zoom
            float zIn =  Sys.Input.GamePad.Triggers.Right;
            float zOut = Sys.Input.GamePad.Triggers.Left;

            zoomFraction += zDt * timeToZoomIn * (zIn - zOut);

            zoomFraction = Maths.Euclid.Clamp(zoomFraction, 1.0f, 0.0f);


            if (Sys.Input.GamePad.IsButtonDown(Buttons.LeftShoulder))
                yaw += zDt * rotationSpeed;

            if (Sys.Input.GamePad.IsButtonDown(Buttons.RightShoulder))
                yaw -= zDt * rotationSpeed;
 
        }

        public void Reset()
        {
            zoomFraction = 0.7f;
            yaw = 0.0f;

            xz.D = 4.0f;
            xz.Normal = Vector3.Up;
        }

        public void Apply(float zDt, CameraState zState, CameraState zPreviousCameraState)
        {
            
            //Rotate the camera to look down, and then move it up a bit
            //Matrix rot = Matrix.CreateFromYawPitchRoll(0, -pitch/ 2.0f, 0);

            float pitch = (zoomFraction * (maxPitch - minPitch) + minPitch) * Maths.Euclid.PI / 180.0f;
            float height = zoomFraction * (maxHeight - minHeight) + minHeight;

            Quaternion rotationFromInputs = Quaternion.CreateFromYawPitchRoll(yaw, pitch, 0.0f);
            Quaternion currentOri = zState.Orientation;
            zState.Orientation = Quaternion.Multiply(currentOri, rotationFromInputs);


            //work out what we should rotate about

            ray.Position = zPreviousCameraState.Position;
            ray.Direction = Matrix.CreateFromQuaternion(zPreviousCameraState.Orientation).Forward;

            float? distanceToGround = ray.Intersects(xz);

            //Vector3 pos;
            


            //Matrix currentOrientation = Matrix.CreateFromQuaternion(zState.Orientation);

            //Matrix newOri = currentOrientation;
            //newOri *= Matrix.CreateRotationX(pitch * Euclid.Euclid.PI / 180.0f);
            //newOri *= Matrix.CreateRotationY(yaw);

            //zState.Orientation = Quaternion.CreateFromRotationMatrix(newOri);

            // Work out the movement from the inputs
            WorkOutTranslation(zDt);

            Vector3 previous = zPreviousCameraState.Position;
            previous.Y = 0.0f;

            zState.Position = 
                zState.Position +
                previous + 
                Vector3.Transform(translation, zState.Orientation) +
                new Vector3(0.0f, height, 0.0f);


            zState.focusDistance = 3.0f;

            //zState.Position = Vector3.Transform(zState.Position, Matrix.CreateTranslation(0, height, 0));



            //// Move the camera side to side
            //zState.Position = Vector3.Transform(zState.Position, Matrix.CreateTranslation(translation.X, 0, translation.Y)*Matrix.CreateRotationY(yaw) );


            
        }
    }
}