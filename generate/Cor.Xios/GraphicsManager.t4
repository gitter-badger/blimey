	public class GraphicsManager
		: IGraphicsManager
	{
		GpuUtils gpuUtils;

		DisplayStatus displayStatus;

		GeometryBuffer currentGeomBuffer;

		public GraphicsManager(OpenTK.Graphics.IGraphicsContext gfxContext)
		{
			gpuUtils = new GpuUtils();
			displayStatus = new DisplayStatus();

			OpenTK.Graphics.ES20.GL.Enable(OpenTK.Graphics.ES20.EnableCap.Blend);
			OpenTKHelper.CheckError();

            // default this
            // todo: all the interfaces need an base abstract implementation
            // where common stuff gets set.
            this.SetBlendEquation(
                BlendFunction.Add, BlendFactor.SourceAlpha, BlendFactor.InverseSourceAlpha,
                BlendFunction.Add, BlendFactor.One, BlendFactor.InverseSourceAlpha);

            /* subtract blend mode

            this.SetBlendEquation(
                BlendFunction.ReverseSubtract, BlendFactor.SourceAlpha, BlendFactor.One,
                BlendFunction.ReverseSubtract, BlendFactor.SourceAlpha, BlendFactor.One)
            */

			OpenTK.Graphics.ES20.GL.Enable(OpenTK.Graphics.ES20.EnableCap.DepthTest);
			OpenTKHelper.CheckError();

			OpenTK.Graphics.ES20.GL.DepthMask(true);
			OpenTKHelper.CheckError();

			OpenTK.Graphics.ES20.GL.DepthRange(0f, 1f);
			OpenTKHelper.CheckError();

			OpenTK.Graphics.ES20.GL.DepthFunc(OpenTK.Graphics.ES20.DepthFunction.Lequal);
			OpenTKHelper.CheckError();

			SetCullMode (CullMode.CW);
		}

		CullMode? currentCullMode;

		public void SetCullMode(CullMode cullMode)
		{
			if (!currentCullMode.HasValue || currentCullMode.Value != cullMode)
			{
				if (cullMode == CullMode.None)
				{
					OpenTK.Graphics.ES20.GL.Disable (OpenTK.Graphics.ES20.EnableCap.CullFace);
					OpenTKHelper.CheckError ();

				}
				else
				{
					OpenTK.Graphics.ES20.GL.Enable(OpenTK.Graphics.ES20.EnableCap.CullFace);
					OpenTKHelper.CheckError();

					OpenTK.Graphics.ES20.GL.FrontFace(OpenTK.Graphics.ES20.FrontFaceDirection.Cw);
					OpenTKHelper.CheckError();

					if (cullMode == CullMode.CW)
					{
						OpenTK.Graphics.ES20.GL.CullFace (OpenTK.Graphics.ES20.CullFaceMode.Back);
						OpenTKHelper.CheckError ();
					}
					else if (cullMode == CullMode.CCW)
					{
						OpenTK.Graphics.ES20.GL.CullFace (OpenTK.Graphics.ES20.CullFaceMode.Front);
						OpenTKHelper.CheckError ();
					}
					else
					{
						throw new NotSupportedException();
					}
				}

				currentCullMode = cullMode;
			}
		}

		public void Reset()
		{
			this.ClearDepthBuffer();
			this.ClearColourBuffer();
			this.SetActiveGeometryBuffer(null);

			// todo, here we need to set all the texture slots to point to null
			this.SetActiveTexture(0, null);
		}

		/*
		// Clear all buffers to default values.
		public void Clear()
		{
			var mask =
				OpenTK.Graphics.ES20.ClearBufferMask.ColorBufferBit &
				OpenTK.Graphics.ES20.ClearBufferMask.DepthBufferBit &
				OpenTK.Graphics.ES20.ClearBufferMask.StencilBufferBit;

			OpenTK.Graphics.ES20.GL.Clear ( (Int32) mask );

			OpenTKHelper.CheckError();

		}
*/

		public void SetActiveTexture(Int32 slot, Texture2D tex)
        {
            OpenTK.Graphics.ES20.TextureUnit oglTexSlot = EnumConverter.ToOpenTKTextureSlot(slot); 
            OpenTK.Graphics.ES20.GL.ActiveTexture(oglTexSlot);

			var oglt0 = tex as OglesTexture;
            
            if( oglt0 != null )
            {
                var textureTarget = OpenTK.Graphics.ES20.TextureTarget.Texture2D;
                
                // we need to bind the texture object so that we can opperate on it.
                OpenTK.Graphics.ES20.GL.BindTexture(textureTarget, oglt0.glTextureId);
                OpenTKHelper.CheckError();
            }

        }
        
		public void ClearColourBuffer(Rgba32 col = new Rgba32())
		{
			Vector4 c;

            col.UnpackTo(out c);

			OpenTK.Graphics.ES20.GL.ClearColor (c.X, c.Y, c.Z, c.W);

			var mask = OpenTK.Graphics.ES20.ClearBufferMask.ColorBufferBit;

			OpenTK.Graphics.ES20.GL.Clear ( mask );

			OpenTKHelper.CheckError();
		}

        public void ClearDepthBuffer(Single val = 1)
		{
			OpenTK.Graphics.ES20.GL.ClearDepth(val);

			var mask = OpenTK.Graphics.ES20.ClearBufferMask.DepthBufferBit;

			OpenTK.Graphics.ES20.GL.Clear ( mask );

			OpenTKHelper.CheckError();
		}

		public IGpuUtils GpuUtils
		{
			get
			{
				return gpuUtils;
			}
		}

        public IGeometryBuffer CreateGeometryBuffer(
			VertexDeclaration vertexDeclaration, Int32 vertexCount, Int32 indexCount)
		{
			return new GeometryBuffer(vertexDeclaration, vertexCount, indexCount);
		}

        public void SetActiveGeometryBuffer(IGeometryBuffer buffer)
		{
			var temp = buffer as GeometryBuffer;

            if( temp != this.currentGeomBuffer )
            {
                if( this.currentGeomBuffer != null )
                {
                    this.currentGeomBuffer.Deactivate();

                    this.currentGeomBuffer = null;
                }

                if( temp != null )
                {
                    temp.Activate();
                }
                
                this.currentGeomBuffer = temp;
            }
		}

        public IDisplayStatus DisplayStatus
		{
			get
			{
				return displayStatus;
			}
		}

        public void DrawIndexedPrimitives(
			PrimitiveType primitiveType,            // Describes the type of primitive to render. PrimitiveType.PointList is not supported with this method.
            Int32 baseVertex,                       // Offset to add to each vertex index in the index buffer.
            Int32 minVertexIndex,                   // Minimum vertex index for vertices used during the call. The minVertexIndex parameter and all of the indices in the index stream are relative to the baseVertex parameter.
            Int32 numVertices,                      // Number of vertices used during the call. The first vertex is located at index: baseVertex + minVertexIndex.
            Int32 startIndex,                       // Location in the index array at which to start reading vertices.
            Int32 primitiveCount                    // Number of primitives to render. The number of vertices used is a function of primitiveCount and primitiveType.
            )
		{

            if( baseVertex != 0 || minVertexIndex != 0 || startIndex != 0 )
            {
                throw new NotImplementedException();
            }

			var otkpType =  EnumConverter.ToOpenTK(primitiveType);
			//Int32 numVertsInPrim = numVertices / primitiveCount;

			Int32 nVertsInPrim = PrimitiveHelper.NumVertsIn(primitiveType);
			Int32 count = primitiveCount * nVertsInPrim;

			var vertDecl = currentGeomBuffer.VertexBuffer.VertexDeclaration;

			this.EnableVertAttribs( vertDecl, (IntPtr) 0 );

			OpenTK.Graphics.ES20.GL.DrawElements (
				otkpType,
				count,
				OpenTK.Graphics.ES20.DrawElementsType.UnsignedShort,
				(System.IntPtr) 0 );

			OpenTKHelper.CheckError();

			this.DisableVertAttribs(vertDecl);

		}

#if AOT
		public void DrawUserPrimitives (PrimitiveType primitiveType, VertexPosition[] vertexData, Int32 vertexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration ) { this.DrawUserPrimitivesHelper (primitiveType, vertexData, vertexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserPrimitives (PrimitiveType primitiveType, VertexPositionColour[] vertexData, Int32 vertexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration ) { this.DrawUserPrimitivesHelper (primitiveType, vertexData, vertexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserPrimitives (PrimitiveType primitiveType, VertexPositionNormal[] vertexData, Int32 vertexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration ) { this.DrawUserPrimitivesHelper (primitiveType, vertexData, vertexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserPrimitives (PrimitiveType primitiveType, VertexPositionNormalColour[] vertexData, Int32 vertexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration ) { this.DrawUserPrimitivesHelper (primitiveType, vertexData, vertexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserPrimitives (PrimitiveType primitiveType, VertexPositionNormalTexture[] vertexData, Int32 vertexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration ) { this.DrawUserPrimitivesHelper (primitiveType, vertexData, vertexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserPrimitives (PrimitiveType primitiveType, VertexPositionNormalTextureColour[] vertexData, Int32 vertexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration ) { this.DrawUserPrimitivesHelper (primitiveType, vertexData, vertexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserPrimitives (PrimitiveType primitiveType, VertexPositionTexture[] vertexData, Int32 vertexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration ) { this.DrawUserPrimitivesHelper (primitiveType, vertexData, vertexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserPrimitives (PrimitiveType primitiveType, VertexPositionTextureColour[] vertexData, Int32 vertexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration ) { this.DrawUserPrimitivesHelper (primitiveType, vertexData, vertexOffset, primitiveCount, vertexDeclaration); }

		void DrawUserPrimitivesHelper<T>(
#else
        public void DrawUserPrimitives<T>(
#endif
			PrimitiveType primitiveType,
			T[] vertexData,
			int vertexOffset,
			int primitiveCount,
			VertexDeclaration vertexDeclaration)
			where T : struct, IVertexType
		{
            // do i need to do this? todo: find out
			this.SetActiveGeometryBuffer(null);

			var vertDecl = vertexData[0].VertexDeclaration;

			//MSDN
			//
			//The GCHandle structure is used with the GCHandleType 
			//enumeration to create a handle corresponding to any managed 
			//object. This handle can be one of four types: Weak, 
			//WeakTrackResurrection, Normal, or Pinned. When the handle has 
			//been allocated, you can use it to prevent the managed object 
			//from being collected by the garbage collector when an unmanaged 
			//client holds the only reference. Without such a handle, 
			//the object can be collected by the garbage collector before 
			//completing its work on behalf of the unmanaged client.
			//
			//You can also use GCHandle to create a pinned object that 
			//returns a memory address to prevent the garbage collector 
			//from moving the object in memory.
			//
			//When the handle goes out of scope you must explicitly release 
			//it by calling the Free method; otherwise, memory leaks may 
			//occur. When you free a pinned handle, the associated object
			//will be unpinned and will become eligible for garbage 
			//collection, if there are no other references to it.
			//
			GCHandle pinnedArray = GCHandle.Alloc(vertexData, GCHandleType.Pinned);
			IntPtr pointer = pinnedArray.AddrOfPinnedObject();

			if( vertexOffset != 0 )
			{
				pointer = Add(pointer, vertexOffset * vertDecl.VertexStride * sizeof(byte));
			}

			var glDrawMode = EnumConverter.ToOpenTK(primitiveType);
			var glDrawModeAll = glDrawMode;


			var bindTarget = OpenTK.Graphics.ES20.BufferTarget.ArrayBuffer;

			OpenTK.Graphics.ES20.GL.BindBuffer(bindTarget, 0);
			OpenTKHelper.CheckError();


			this.EnableVertAttribs( vertDecl, pointer );

			Int32 nVertsInPrim = PrimitiveHelper.NumVertsIn(primitiveType);
			Int32 count = primitiveCount * nVertsInPrim;

			OpenTK.Graphics.ES20.GL.DrawArrays(
				glDrawModeAll, // specifies the primitive to render
				vertexOffset,  // specifies the starting vertex index in the enabled vertex arrays
				count ); // specifies the number of indicies to be drawn

			OpenTKHelper.CheckError();


			this.DisableVertAttribs(vertDecl);


			pinnedArray.Free();

		}

		[ReliabilityContract (Consistency.MayCorruptInstance, Cer.MayFail)]
		static IntPtr Add (IntPtr pointer, int offset)
		{
			unsafe
			{
				return (IntPtr) (unchecked (((byte *) pointer) + offset));
			}
		}

		[ReliabilityContract (Consistency.MayCorruptInstance, Cer.MayFail)]
		static IntPtr Subtract (IntPtr pointer, int offset)
		{
			unsafe
			{
				return (IntPtr) (unchecked (((byte *) pointer) - offset));
			}
		}

		void EnableVertAttribs(VertexDeclaration vertDecl, IntPtr pointer)
		{
			var vertElems = vertDecl.GetVertexElements();

			IntPtr ptr = pointer;

			int counter = 0;
			foreach(var elem in vertElems)
			{
				OpenTK.Graphics.ES20.GL.EnableVertexAttribArray(counter);
				OpenTKHelper.CheckError();

				//var vertElemUsage = elem.VertexElementUsage;
				var vertElemFormat = elem.VertexElementFormat;
				var vertElemOffset = elem.Offset;

				Int32 numComponentsInVertElem = 0;
				Boolean vertElemNormalized = false;
				OpenTK.Graphics.ES20.VertexAttribPointerType glVertElemFormat;

				EnumConverter.ToOpenTK(vertElemFormat, out glVertElemFormat, out vertElemNormalized, out numComponentsInVertElem);

				if( counter != 0)
				{
					ptr = Add(ptr, vertElemOffset);
				}

				OpenTK.Graphics.ES20.GL.VertexAttribPointer(
					counter,				// index - specifies the generic vertex attribute index.  This value is 0 to
											//         max vertex attributes supported - 1.
					numComponentsInVertElem,// size - number of components specified in the vertex array for the
											//        vertex attribute referenced by index.  Valid values are 1 - 4.
					glVertElemFormat,		// type - Data format, valid values are GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT,
											//        GL_FLOAT, GL_FIXED, GL_HALF_FLOAT_OES*(Optional feature of es2)
					vertElemNormalized,		// normalised - used to indicate whether the non-floating data format type should be normalised
											//              or not when converted to floating point.
					vertDecl.VertexStride,	// stride - the components of vertex attribute specified by size are stored sequentially for each
											//          vertex.  stride specifies the delta between data for vertex index 1 and vertex (1 + 1).
											//          If stride is 0, attribute data for all vertices are stored sequentially.
											//          If stride is > 0, then we use the stride valude tas the pitch to get vertex data
											//          for the next index.
					ptr
					
					);

				OpenTKHelper.CheckError();

				counter++;

			}
		}

		void DisableVertAttribs(VertexDeclaration vertDecl)
		{
			var vertElems = vertDecl.GetVertexElements();

			for(int i = 0; i < vertElems.Length; ++i)
			{
				OpenTK.Graphics.ES20.GL.DisableVertexAttribArray(i);
				OpenTKHelper.CheckError();
			}
		}

		public void SetBlendEquation(
            BlendFunction rgbBlendFunction, BlendFactor sourceRgb, BlendFactor destinationRgb,
            BlendFunction alphaBlendFunction, BlendFactor sourceAlpha, BlendFactor destinationAlpha
            )
        {
            OpenTK.Graphics.ES20.GL.BlendEquationSeparate(
                EnumConverter.ToOpenTK(rgbBlendFunction),
                EnumConverter.ToOpenTK(alphaBlendFunction) );
            OpenTKHelper.CheckError();

            OpenTK.Graphics.ES20.GL.BlendFuncSeparate(
                EnumConverter.ToOpenTKSrc(sourceRgb),
                EnumConverter.ToOpenTKDest(destinationRgb),
                EnumConverter.ToOpenTKSrc(sourceAlpha),
                EnumConverter.ToOpenTKDest(destinationAlpha) );
            OpenTKHelper.CheckError();

        }

#if AOT
		public void DrawUserIndexedPrimitives (PrimitiveType primitiveType, VertexPosition[] vertexData, Int32 vertexOffset, Int32 numVertices, Int32[] indexData, Int32 indexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration) { this.DrawUserIndexedPrimitivesHelper(primitiveType, vertexData, vertexOffset, numVertices, indexData, indexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserIndexedPrimitives (PrimitiveType primitiveType, VertexPositionColour[] vertexData, Int32 vertexOffset, Int32 numVertices, Int32[] indexData, Int32 indexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration) { this.DrawUserIndexedPrimitivesHelper(primitiveType, vertexData, vertexOffset, numVertices, indexData, indexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserIndexedPrimitives (PrimitiveType primitiveType, VertexPositionNormal[] vertexData, Int32 vertexOffset, Int32 numVertices, Int32[] indexData, Int32 indexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration) { this.DrawUserIndexedPrimitivesHelper(primitiveType, vertexData, vertexOffset, numVertices, indexData, indexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserIndexedPrimitives (PrimitiveType primitiveType, VertexPositionNormalColour[] vertexData, Int32 vertexOffset, Int32 numVertices, Int32[] indexData, Int32 indexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration) { this.DrawUserIndexedPrimitivesHelper(primitiveType, vertexData, vertexOffset, numVertices, indexData, indexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserIndexedPrimitives (PrimitiveType primitiveType, VertexPositionNormalTexture[] vertexData, Int32 vertexOffset, Int32 numVertices, Int32[] indexData, Int32 indexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration) { this.DrawUserIndexedPrimitivesHelper(primitiveType, vertexData, vertexOffset, numVertices, indexData, indexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserIndexedPrimitives (PrimitiveType primitiveType, VertexPositionNormalTextureColour[] vertexData, Int32 vertexOffset, Int32 numVertices, Int32[] indexData, Int32 indexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration) { this.DrawUserIndexedPrimitivesHelper(primitiveType, vertexData, vertexOffset, numVertices, indexData, indexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserIndexedPrimitives (PrimitiveType primitiveType, VertexPositionTexture[] vertexData, Int32 vertexOffset, Int32 numVertices, Int32[] indexData, Int32 indexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration) { this.DrawUserIndexedPrimitivesHelper(primitiveType, vertexData, vertexOffset, numVertices, indexData, indexOffset, primitiveCount, vertexDeclaration); }
		public void DrawUserIndexedPrimitives (PrimitiveType primitiveType, VertexPositionTextureColour[] vertexData, Int32 vertexOffset, Int32 numVertices, Int32[] indexData, Int32 indexOffset, Int32 primitiveCount, VertexDeclaration vertexDeclaration) { this.DrawUserIndexedPrimitivesHelper(primitiveType, vertexData, vertexOffset, numVertices, indexData, indexOffset, primitiveCount, vertexDeclaration); }

		void DrawUserIndexedPrimitivesHelper<T>(
#else
        public void DrawUserIndexedPrimitives<T>(
#endif
            PrimitiveType primitiveType,            // Describes the type of primitive to render.
            T[] vertexData,                         // The vertex data.
            Int32 vertexOffset,                     // Offset (in vertices) from the beginning of the vertex buffer to the first vertex to draw.
            Int32 numVertices,                      // Number of vertices to draw.
            Int32[] indexData,                      // The index data.
            Int32 indexOffset,                      // Offset (in indices) from the beginning of the index buffer to the first index to use.
            Int32 primitiveCount,                   // Number of primitives to render.
            VertexDeclaration vertexDeclaration)
			where T : struct, IVertexType
        {
            throw new NotImplementedException();
        }

        public void DrawPrimitives(
            PrimitiveType primitiveType,            // Describes the type of primitive to render.
            Int32 startVertex,                      // Index of the first vertex to load. Beginning at startVertex, the correct number of vertices is read out of the vertex buffer.
            Int32 primitiveCount)                   // Number of primitives to render. The primitiveCount is the number of primitives as determined by the primitive type. If it is a line list, each primitive has two vertices. If it is a triangle list, each primitive has three vertices.
		{
            throw new NotImplementedException();
        }
	}
