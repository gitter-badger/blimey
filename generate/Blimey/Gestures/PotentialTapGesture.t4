    internal class PotentialTapGesture
        : PotentialGesture
    {
        const Single MaxHoldTimeForTap = 0.6f;
        const Single MaxDisplacementForTap = 0.005f;

        Single timer = 0f;

        internal PotentialTapGesture(InputEventSystem inputEventSystem, Int32[] touchIDs)
            : base(inputEventSystem, GestureType.Tap, touchIDs)
        {

        }

        internal override Gesture Update(float dt, List<TouchTracker> touchTrackers)
        {
            if( failedGesture )
                throw new Exception("wrong!");

            this.timer += dt;

            if( this.timer > MaxHoldTimeForTap)
                failedGesture = true;

            var touchTracker = inputEventSystem.GetTouchTracker(touchIDs[0]);

            if (touchTracker == null)
            {
                failedGesture = true;
                return null;
            }


            if( touchTracker.Phase == TouchPhase.JustReleased )
            {
                float distanceTravelled = touchTracker.GetDistanceTraveled(TouchPositionSpace.RealWorld);
                if (distanceTravelled <= MaxDisplacementForTap)
                {
                    completedGesture = true;
                    return new Gesture(this.inputEventSystem, this.type, this.touchIDs);
                }
                else
                {
                    failedGesture = true;
                }

            }

            return null;
        }
    }

