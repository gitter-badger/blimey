    public sealed class KrShaderVariable
    {
        int ProgramHandle { get; set; }
        internal int UniformLocation { get; private set; }

        public String NiceName { get; private set; }
        public String Name { get; private set; }
        public Type Type { get; private set; }
        public Object DefaultValue { get; private set; }

        public KrShaderVariable(
            int programHandle, KrShaderUtils.KrShaderUniform uniform)
        {

            this.ProgramHandle = programHandle;

            int uniformLocation = GL.GetUniformLocation(programHandle, uniform.Name);

            KrErrorHandler.Check();

            if( uniformLocation == -1 )
                throw new Exception();

            this.UniformLocation = uniformLocation;
            this.Name = uniform.Name;
            this.Type = Cor.Lib.Khronos.KrEnumConverter.ToType(uniform.Type);

            InternalUtils.Log.Info(
                String.Format(
                "    Caching Reference to Shader Variable: [Prog={0}, UniIndex={1}, UniLocation={2}, UniName={3}, UniType={4}]",
                programHandle,
                uniform.Index,
                uniformLocation,
                uniform.Name,
                uniform.Type));

        }

        internal void RegisterExtraInfo(ShaderVariableDefinition definition)
        {
            NiceName = definition.NiceName;
            DefaultValue = definition.DefaultValue;
        }

        public void Set(object value)
        {
            //todo this should be using convert turn the data into proper opengl es types.
            Type t = value.GetType();

            if( t == typeof(Matrix44) )
            {
                var castValue = (Matrix44) value;
                var otkValue = KrMatrix44Converter.ToKhronos(castValue);
                GL.UniformMatrix4( UniformLocation, false, ref otkValue );
            }
            else if( t == typeof(Int32) )
            {
                var castValue = (Int32) value;
                GL.Uniform1( UniformLocation, 1, ref castValue );
            }
            else if( t == typeof(Single) )
            {
                var castValue = (Single) value;
                GL.Uniform1( UniformLocation, 1, ref castValue );
            }
            else if( t == typeof(Abacus.SinglePrecision.Vector2) )
            {
                var castValue = (Abacus.SinglePrecision.Vector2) value;
                GL.Uniform2( UniformLocation, 1, ref castValue.X );
            }
            else if( t == typeof(Abacus.SinglePrecision.Vector3) )
            {
                var castValue = (Abacus.SinglePrecision.Vector3) value;
                GL.Uniform3( UniformLocation, 1, ref castValue.X );
            }
            else if( t == typeof(Abacus.SinglePrecision.Vector4) )
            {
                var castValue = (Abacus.SinglePrecision.Vector4) value;
                GL.Uniform4( UniformLocation, 1, ref castValue.X );
            }
            else if( t == typeof(Rgba32) )
            {
                var castValue = (Rgba32) value;

                Abacus.SinglePrecision.Vector4 vec4Value;
                castValue.UnpackTo(out vec4Value);

                // does this rgba value need to be packed in to a vector3 or a vector4
                if( this.Type == typeof(Abacus.SinglePrecision.Vector4) )
                    GL.Uniform4( UniformLocation, 1, ref vec4Value.X );
                else if( this.Type == typeof(Abacus.SinglePrecision.Vector3) )
                    GL.Uniform3( UniformLocation, 1, ref vec4Value.X );
                else
                    throw new Exception("Not supported");
            }
            else
            {
                throw new Exception("Not supported");
            }

            KrErrorHandler.Check();

        }
    }

