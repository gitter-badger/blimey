    public class FreeTransform
        : Trait
    {
        public FreeTransform()
        {
        }
    }

/*


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;


namespace SunGiant.Framework.Ophelia.Cameras
{

    public class FreeCamInputs
    {
        public Vector3 mTranslation;
        public Vector3 mRotation;
        public float mTranslationSpeed; //in range 0-1
        public float mRotationSpeedScale;
        public bool mFixUp;
    }

    public class FreeCamBehavior
        : Behavior
    {

        Vector3 oldPosition = Vector3.Zero;
        KeyboardState currentKeyboardState = new KeyboardState();
        GamePadState currentGamePadState = new GamePadState();

        // inputs that come from the controller
        FreeCamInputs mInputs;

        // fre cam settings
        float mTranslationSpeedStandard = 10.0f;
        float mTranslationSpeedMaximum = 100.0f;
        float mRotationSpeed = 45.0f; //30 degrees per second

        public void WorkOutInputs()
        {
            currentKeyboardState = Keyboard.GetState();
            currentGamePadState = GamePad.GetState(PlayerIndex.One);

            FreeCamInputs input = new FreeCamInputs();

            input.mTranslation = new Vector3(
                currentGamePadState.ThumbSticks.Left.X,
                0.0f,
                -currentGamePadState.ThumbSticks.Left.Y
                );

            input.mRotation = new Vector3(
                -currentGamePadState.ThumbSticks.Right.Y,
                -currentGamePadState.ThumbSticks.Right.X,
                0.0f
                );

            input.mTranslationSpeed = currentGamePadState.Triggers.Right;

            input.mRotationSpeedScale = 1.0f;

           input.mFixUp = currentKeyboardState.IsKeyDown(Keys.U);
            SetInputs(input);
        }

        public void SetInputs(FreeCamInputs zIn) { mInputs = zIn; }


        public void Reset()
        {
            //need to change this to that these values tie in with whatever the camera was looking at before
            localPitch=0.0f;
            localYaw = 0.0f;
            localRoll = 0.0f;
            oldPosition = Vector3.Zero;
        }

        float localPitch;
        float localYaw;
        float localRoll;

        public void Apply(float zDt, CameraState zState, CameraState zPreviousCameraState)
        {
            WorkOutInputs();

            float translationSpeed = mTranslationSpeedStandard
                + mInputs.mTranslationSpeed *
                (mTranslationSpeedMaximum - mTranslationSpeedStandard);

            Vector3 translation = mInputs.mTranslation * translationSpeed * zDt;

            Vector3 rotation =
                mInputs.mRotation *
                MathHelper.ToRadians(mRotationSpeed) *
                mInputs.mRotationSpeedScale * zDt;

            localPitch += rotation.X;
            localYaw += rotation.Y;
            localRoll += rotation.Z;

            Quaternion rotationFromInputs = Quaternion.CreateFromYawPitchRoll(localYaw, localPitch, localRoll);

            Quaternion currentOri = zState.Orientation;

            zState.Orientation = Quaternion.Multiply( currentOri, rotationFromInputs);

            float yTranslation = translation.Y;
            translation.Y = 0.0f;

            zState.Position += oldPosition + Vector3.Transform(translation, zState.Orientation) + new Vector3(0.0f, yTranslation, 0.0f);
            zState.focusDistance = 3.0f;

            //update the old position for next time
            oldPosition = zState.Position;
            mInputs = null;

        }
    }
}*/