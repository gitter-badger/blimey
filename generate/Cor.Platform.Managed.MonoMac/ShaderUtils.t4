    //
    // Shader Utils
    // ------------
    // Static class to help with open tk's horrible shader system.
    //
    public static class ShaderUtils
    {
        public class ShaderUniform
        {
            public Int32 Index { get; set; }
            public String Name { get; set; }
            public global::MonoMac.OpenGL.ActiveUniformType Type { get; set; }
        }

        public class ShaderAttribute
        {
            public Int32 Index { get; set; }
            public String Name { get; set; }
            public global::MonoMac.OpenGL.ActiveAttribType Type { get; set; }
        }
        
        public static Int32 CreateShaderProgram()
        {
            // Create shader program.
            Int32 programHandle = global::MonoMac.OpenGL.GL.CreateProgram ();

            if( programHandle == 0 )
                throw new Exception("Failed to create shader program");

            OpenGLHelper.CheckError();

            return programHandle;
        }

        public static Int32 CreateVertexShader(string path)
        {
            Int32 vertShaderHandle;
            string ext = Path.GetExtension(path);

            if( ext != ".vsh" )
            {
                throw new Exception("Resource [" + path + "] should end with .vsh");
            }

            string filename = path.Substring(0, path.Length - ext.Length);

            var vertShaderPathname =
                global::MonoMac.Foundation.NSBundle.MainBundle.PathForResource (
                    filename,
                    "vsh" );

            if( vertShaderPathname == null )
            {
                throw new Exception("Resource [" + path + "] not found");
            }


            //Console.WriteLine ("[Cor.Resources] " + vertShaderPathname);


            ShaderUtils.CompileShader (
                global::MonoMac.OpenGL.ShaderType.VertexShader, 
                vertShaderPathname, 
                out vertShaderHandle );

            if( vertShaderHandle == 0 )
                throw new Exception("Failed to compile vertex shader program");

            return vertShaderHandle;
        }

        public static Int32 CreateFragmentShader(string path)
        {
            Int32 fragShaderHandle;

            string ext = Path.GetExtension(path);
            
            if( ext != ".fsh" )
            {
                throw new Exception("Resource [" + path + "] should end with .fsh");
            }
            
            string filename = path.Substring(0, path.Length - ext.Length);
            
            var fragShaderPathname =
                global::MonoMac.Foundation.NSBundle.MainBundle.PathForResource (
                    filename,
                    "fsh" );
            
            if( fragShaderPathname == null )
            {
                throw new Exception("Resource [" + path + "] not found");
            }

            //Console.WriteLine ("[Cor.Resources] " + fragShaderPathname);


            ShaderUtils.CompileShader (
                global::MonoMac.OpenGL.ShaderType.FragmentShader,
                fragShaderPathname,
                out fragShaderHandle );

            if( fragShaderHandle == 0 )
                throw new Exception("Failed to compile fragment shader program");


            return fragShaderHandle;
        }

        public static void AttachShader(
            Int32 programHandle,
            Int32 shaderHandle)
        {
            if (shaderHandle != 0)
            {
                // Attach vertex shader to program.
                global::MonoMac.OpenGL.GL.AttachShader (programHandle, shaderHandle);
                OpenGLHelper.CheckError();
            }
        }

        public static void DetachShader(
            Int32 programHandle,
            Int32 shaderHandle )
        {
            if (shaderHandle != 0)
            {
                global::MonoMac.OpenGL.GL.DetachShader (programHandle, shaderHandle);
                OpenGLHelper.CheckError();
            }
        }

        public static void DeleteShader(
            Int32 programHandle,
            Int32 shaderHandle )
        {
            if (shaderHandle != 0)
            {
                global::MonoMac.OpenGL.GL.DeleteShader (shaderHandle);
                shaderHandle = 0;
                OpenGLHelper.CheckError();
            }
        }
        
        public static void DestroyShaderProgram (Int32 programHandle)
        {
            if (programHandle != 0)
            {
                global::MonoMac.OpenGL.GL.DeleteProgram (1, new int[]{ programHandle } );
                programHandle = 0;
                OpenGLHelper.CheckError();
            }
        }

        public static void CompileShader (
            global::MonoMac.OpenGL.ShaderType type,
            String file,
            out Int32 shaderHandle )
        {
            String src = string.Empty;

            try
            {
                // Get the data from the text file
                src = System.IO.File.ReadAllText (file);
            }
            catch(Exception e)
            {
                Console.WriteLine(e.Message);
                shaderHandle = 0;
                return;
            }

            // Create an empty vertex shader object
            shaderHandle = global::MonoMac.OpenGL.GL.CreateShader (type);

            OpenGLHelper.CheckError();

            // Replace the source code in the vertex shader object
            global::MonoMac.OpenGL.GL.ShaderSource (
                shaderHandle,
                src);
                //1,
                //new String[] { src },
                //(Int32[]) null );

            OpenGLHelper.CheckError();

            global::MonoMac.OpenGL.GL.CompileShader (shaderHandle);

            OpenGLHelper.CheckError();
            
#if DEBUG
            Int32 logLength = 0;
            global::MonoMac.OpenGL.GL.GetShader (
                shaderHandle,
                global::MonoMac.OpenGL.ShaderParameter.InfoLogLength,
                out logLength);

            OpenGLHelper.CheckError();
            var infoLog = new System.Text.StringBuilder(logLength);

            if (logLength > 0)
            {
                int temp = 0;
                global::MonoMac.OpenGL.GL.GetShaderInfoLog (
                    shaderHandle,
                    logLength,
                    out temp,
                    infoLog );

                string log = infoLog.ToString();

                Console.WriteLine(file);
                Console.WriteLine (log);
                Console.WriteLine(type);
            }
#endif
            Int32 status = 0;

            global::MonoMac.OpenGL.GL.GetShader (
                shaderHandle,
                global::MonoMac.OpenGL.ShaderParameter.CompileStatus,
                out status );

            OpenGLHelper.CheckError();

            if (status == 0)
            {
                global::MonoMac.OpenGL.GL.DeleteShader (shaderHandle);
                throw new Exception ("Failed to compile " + type.ToString());
            }
        }
        
        public static List<ShaderUniform> GetUniforms (Int32 prog)
        {
            
            int numActiveUniforms = 0;
            
            var result = new List<ShaderUniform>();

            global::MonoMac.OpenGL.GL.GetProgram(prog, global::MonoMac.OpenGL.ProgramParameter.ActiveUniforms, out numActiveUniforms);
            OpenGLHelper.CheckError();

            for(int i = 0; i < numActiveUniforms; ++i)
            {
                var sb = new System.Text.StringBuilder ();
                
                int buffSize = 0;
                int length = 0;
                int size = 0;
                global::MonoMac.OpenGL.ActiveUniformType type;

                global::MonoMac.OpenGL.GL.GetActiveUniform(
                    prog,
                    i,
                    64,
                    out length,
                    out size,
                    out type,
                    sb);
                OpenGLHelper.CheckError();
                
                result.Add(
                    new ShaderUniform()
                    {
                    Index = i,
                    Name = sb.ToString(),
                    Type = type
                    }
                );
            }
            
            return result;
        }

        public static List<ShaderAttribute> GetAttributes (Int32 prog)
        {
            int numActiveAttributes = 0;
            
            var result = new List<ShaderAttribute>();
            
            // gets the number of active vertex attributes
            global::MonoMac.OpenGL.GL.GetProgram(prog, global::MonoMac.OpenGL.ProgramParameter.ActiveAttributes, out numActiveAttributes);
            OpenGLHelper.CheckError();

            for(int i = 0; i < numActiveAttributes; ++i)
            {
                var sb = new System.Text.StringBuilder ();

                int buffSize = 0;
                int length = 0;
                int size = 0;
                global::MonoMac.OpenGL.ActiveAttribType type;
                global::MonoMac.OpenGL.GL.GetActiveAttrib(
                    prog,
                    i,
                    64,
                    out length,
                    out size,
                    out type,
                    sb);
                OpenGLHelper.CheckError();
                    
                result.Add(
                    new ShaderAttribute()
                    {
                        Index = i,
                        Name = sb.ToString(),
                        Type = type
                    }
                );
            }
            
            return result;
        }
        
        
        public static bool LinkProgram (Int32 prog)
        {
            bool retVal = true;

            global::MonoMac.OpenGL.GL.LinkProgram (prog);

            OpenGLHelper.CheckError();
            
#if DEBUG
            Int32 logLength = 0;

            global::MonoMac.OpenGL.GL.GetProgram (
                prog,
                global::MonoMac.OpenGL.ProgramParameter.InfoLogLength,
                out logLength );

            OpenGLHelper.CheckError();

            if (logLength > 0)
            {
                retVal = false;

                /*
                var infoLog = new System.Text.StringBuilder ();

                global::MonoMac.OpenGL.GL.GetProgramInfoLog (
                    prog,
                    logLength,
                    out logLength,
                    infoLog );
                */
                var infoLog = string.Empty;
                global::MonoMac.OpenGL.GL.GetProgramInfoLog(prog, out infoLog);


                OpenGLHelper.CheckError();

                Console.WriteLine (string.Format("[Cor.Resources] Program link log:\n{0}", infoLog));
            }
#endif
            Int32 status = 0;

            global::MonoMac.OpenGL.GL.GetProgram (
                prog,
                global::MonoMac.OpenGL.ProgramParameter.LinkStatus,
                out status );

            OpenGLHelper.CheckError();

            if (status == 0)
            {
                throw new Exception(String.Format("Failed to link program: {0:x}", prog));
            }

            return retVal;

        }

        public static void ValidateProgram (Int32 programHandle)
        {
            global::MonoMac.OpenGL.GL.ValidateProgram (programHandle);

            OpenGLHelper.CheckError();
            
            Int32 logLength = 0;

            global::MonoMac.OpenGL.GL.GetProgram (
                programHandle,
                global::MonoMac.OpenGL.ProgramParameter.InfoLogLength,
                out logLength );

            OpenGLHelper.CheckError();

            if (logLength > 0)
            {
                var infoLog = new System.Text.StringBuilder ();

                global::MonoMac.OpenGL.GL.GetProgramInfoLog (
                    programHandle,
                    logLength,
                    out logLength, infoLog );

                OpenGLHelper.CheckError();

                Console.WriteLine (string.Format("[Cor.Resources] Program validate log:\n{0}", infoLog));
            }
            
            Int32 status = 0;

            global::MonoMac.OpenGL.GL.GetProgram (
                programHandle, global::MonoMac.OpenGL.ProgramParameter.LinkStatus,
                out status );

            OpenGLHelper.CheckError();

            if (status == 0)
            {
                throw new Exception (String.Format("Failed to validate program {0:x}", programHandle));
            }
        }
    }

