    // Game Object
    // -----------
    //
    public sealed class SceneObject
    {
        List<Trait> behaviours = new List<Trait> ();
        Transform location = new Transform ();
        String name = "SceneObject";
        readonly Scene containedBy;
        Boolean enabled = false;
        
        public Scene Owner { get { return containedBy; } }
        
        // Used to define where in the game engine's hierarchy this
        // game object exists.
        public Transform Transform { get { return location; } }
        
        // The name of the this game object, defaults to "SceneObject"
        // can be set upon creation or changed at anytime.  Only real
        // use is to doing lazy searches of the hierachy by name
        // and also making the hierachy look neat.
        public string Name { get { return name; } set { name = value; } }
        
        // Defines whether or not the SceneObject's behaviours should be updated
        // and rendered.
        public Boolean Enabled
        { 
            get 
            {
                return enabled; 
            }
            set 
            {
                if( enabled == value )
                    return;
                
                Boolean changeFlag = false;
            
                changeFlag = true;
                enabled = value;
                
                if( changeFlag )
                {
                    foreach (var behaviour in behaviours) 
                    {
                        if(enabled)
                            behaviour.OnEnable();
                        else
                            behaviour.OnDisable();
                    }
                }   
            } 
        }
        
        
        internal List<SceneObject> Children {
            get {
                List<SceneObject> kids = new List<SceneObject> ();
                foreach (SceneObject go in containedBy.SceneObjects) {
                    if (go.Transform.Parent == this.Transform)
                        kids.Add (go);
                }
                return kids;
            }
        }

        
        public T AddTrait<T> ()
            where T : Trait, new()
        {
            
            if( this.GetTrait<T>() != null )
                throw new Exception("This Trait already exists on the gameobject");
            
            T behaviour = new T ();
            behaviours.Add (behaviour);
            behaviour.Initilise(containedBy.Cor, containedBy.Blimey, this);
            
            behaviour.OnAwake();
            
            if( this.Enabled )
                behaviour.OnEnable();
            else
                behaviour.OnDisable();
            
            return behaviour;

        }

        public void RemoveTrait<T> ()
            where T : Trait
        {
            Trait trait = behaviours.Find(x => x is T );
            trait.OnDestroy();
            behaviours.Remove(trait);
        }

        public T GetTrait<T> ()
            where T : Trait
        {
            foreach (Trait b in behaviours) {
                if (b as T != null)
                    return b as T;
            }

            return null;
        }

        public T GetTraitInChildren<T> ()
            where T : Trait
        {
            foreach (var go in Children) {
                foreach (var b in go.behaviours) {
                    if (b as T != null)
                        return b as T;
                }
            }

            return null;
        }

        internal SceneObject (Scene containedBy, string name)
        {
            this.Name = name;
            
            this.containedBy = containedBy;
            
            // directly set _enabled to false, don't want any callbacks yet
            this.enabled = true;
            
        }

        internal void Update(AppTime time)
        {
            if (!Enabled)
                return;
            
            foreach (Trait behaviour in behaviours) {
                if (behaviour.Active)
                {
                    behaviour.OnUpdate(time);
                }
            }
        }
        
        internal void Render(IGraphicsManager zGfx, Matrix44 zView, Matrix44 zProjection){
            if (!Enabled)
                return;
            
            foreach (Trait behaviour in behaviours) {
                if (behaviour.Active)
                    behaviour.Render(zGfx, zView, zProjection);
            }
        }

        internal void Shutdown ()
        {
            foreach (var behaviour in behaviours) 
            {
                behaviour.OnDestroy ();
            }
        }
    }

