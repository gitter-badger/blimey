    public sealed class KrShader
        : IDisposable
    {
        public List<KrShaderInput> Inputs { get; private set; }
        public List<KrShaderVariable> Variables { get; private set; }
        public List<KrShaderSampler> Samplers { get; private set; }

        internal string VariantName { get { return variantName; }}
        Int32 programHandle;
        Int32 fragShaderHandle;
        Int32 vertShaderHandle;

        // for debugging
        string variantName;
        string passName;

        internal KrShader(
            String variantName,
            String passName,
            String vertexShaderSource,
            String pixelShaderSource)
        {
            InternalUtils.Log.Info ("GFX", "  Creating Pass Variant: " + variantName);
            this.variantName = variantName;
            this.passName = passName;

            //Variables =
            programHandle = KrShaderUtils.CreateShaderProgram ();

            vertShaderHandle = KrShaderUtils.CreateVertexShader (vertexShaderSource);
            fragShaderHandle = KrShaderUtils.CreateFragmentShader (pixelShaderSource);

            KrShaderUtils.AttachShader (programHandle, vertShaderHandle);
            KrShaderUtils.AttachShader (programHandle, fragShaderHandle);

        }

        public override string ToString ()
        {
            //string a = Inputs.Select(x => x.Name).Join(", ");
            //string b = Variables.Select(x => x.Name).Join(", ");

            string a = string.Empty;

            for(int i = 0; i < Inputs.Count; ++i)
            {
                a += Inputs[i].Name; if( i + 1 < Inputs.Count ) { a += ", "; }
            }

            string b = string.Empty;
            for(int i = 0; i < Variables.Count; ++i)
            {
                b += Variables[i].Name; if( i + 1 < Variables.Count ) { b += ", "; }
            }

            return
                String.Format (
                    "[KrShader: Variant {0}, Pass {1}: Inputs: [{2}], Variables: [{3}]]",
                    variantName,
                    passName,
                    a,
                    b);
        }

        internal void ValidateInputs(List<ShaderInputDefinition> definitions)
        {
            InternalUtils.Log.Info ("GFX", 
                String.Format (
                    "Pass: {1} => ValidateInputs({0})",
                    variantName,
                    passName ));

            // Make sure that this shader implements all of the non-optional defined inputs.
            var nonOptionalDefinitions = definitions.Where(y => !y.Optional).ToList();

            foreach(var definition in nonOptionalDefinitions)
            {
                var find = Inputs.Find(x => x.Name == definition.Name/* && x.Type == definition.Type */);

                if( find == null )
                {
                    throw new Exception("problem");
                }
            }

            // Make sure that every implemented input is defined.
            foreach(var input in Inputs)
            {
                var find = definitions.Find(x => x.Name == input.Name
                    /*&& (x.Type == input.Type || (x.Type == typeof(Rgba32) && input.Type == typeof(Vector4)))*/
                    );

                if( find == null )
                {
                    throw new Exception("problem");
                }
                else
                {
                    input.RegisterExtraInfo(find);
                }
            }
        }

        internal void ValidateVariables(List<ShaderVariableDefinition> definitions)
        {
            InternalUtils.Log.Info ("GFX", 
                String.Format (
                    "Pass: {1} => ValidateVariables({0})",
                    variantName,
                    passName));


            // Make sure that every implemented input is defined.
            foreach(var variable in Variables)
            {
                var find = definitions.Find(
                    x =>
                    x.Name == variable.Name //&&
                    //(x.Type == variable.Type || (x.Type == typeof(Rgba32) && variable.Type == typeof(Vector4)))
                    );

                if( find == null )
                {
                    throw new Exception("problem");
                }
                else
                {
                    variable.RegisterExtraInfo(find);
                }
            }
        }

        internal void ValidateSamplers(List<ShaderSamplerDefinition> definitions)
        {
            InternalUtils.Log.Info ("GFX", 
                String.Format (
                    "Pass: {1} => ValidateSamplers({0})",
                    variantName,
                    passName ));

            var nonOptionalSamplers =
                definitions
                    .Where(y => !y.Optional)
                    .ToList();

            foreach(var definition in nonOptionalSamplers)
            {
                var find = this.Samplers.Find(x => x.Name == definition.Name);

                if( find == null )
                {
                    throw new Exception("problem");
                }
            }

            // Make sure that every implemented input is defined.
            foreach(var sampler in this.Samplers)
            {
                var find = definitions.Find(x => x.Name == sampler.Name);

                if( find == null )
                {
                    throw new Exception("problem");
                }
                else
                {
                    sampler.RegisterExtraInfo(find);
                }
            }
        }

        static string GetResourcePath(string path)
        {
            string ext = Path.GetExtension(path);

            string filename = path.Substring(0, path.Length - ext.Length);

            var resourcePathname =
#               if COR_PLATFORM_XIOS
                MonoTouch.Foundation.NSBundle.MainBundle.PathForResource (
#               else
                global::MonoMac.Foundation.NSBundle.MainBundle.PathForResource (
#               endif
                    filename,
                    ext.Substring(1, ext.Length - 1)
                );

            if( resourcePathname == null )
            {
                throw new Exception("Resource [" + path + "] not found");
            }

            return resourcePathname;
        }

        internal void BindAttributes(IList<String> orderedAttributes)
        {
            int index = 0;

            foreach(var attName in orderedAttributes)
            {
                GL.BindAttribLocation(programHandle, index, attName);
                KrErrorHandler.Check();
                bool success = KrShaderUtils.LinkProgram (programHandle);
                if (success)
                {
                    index++;
                }

            }
        }

        internal void Link()
        {
            // bind atts here
            //ShaderUtils.LinkProgram (programHandle);

            InternalUtils.Log.Info ("GFX", "  Finishing linking");

            InternalUtils.Log.Info ("GFX", "  Initilise Attributes");
            var attributes = KrShaderUtils.GetAttributes(programHandle);

            Inputs = attributes
                .Select(x => new KrShaderInput(programHandle, x))
                .OrderBy(y => y.AttributeLocation)
                .ToList();

            String logInputs = "  Inputs : ";
            foreach (var input in Inputs) {
                logInputs += input.Name + ", ";
            }
            InternalUtils.Log.Info ("GFX", logInputs);

            InternalUtils.Log.Info ("GFX", "  Initilise Uniforms");
            var uniforms = KrShaderUtils.GetUniforms(programHandle);


            Variables = uniforms
                .Where(y =>
                       y.Type != ActiveUniformType.Sampler2D &&
                       y.Type != ActiveUniformType.SamplerCube)
                .Select(x => new KrShaderVariable(programHandle, x))
                .OrderBy(z => z.UniformLocation)
                .ToList();
            String logVars = "  Variables : ";
            foreach (var variable in Variables) {
                logVars += variable.Name + ", ";
            }
            InternalUtils.Log.Info ("GFX", logVars);

            InternalUtils.Log.Info ("GFX", "  Initilise Samplers");
            Samplers = uniforms
                .Where(y =>
                       y.Type == ActiveUniformType.Sampler2D ||
                       y.Type == ActiveUniformType.SamplerCube)
                .Select(x => new KrShaderSampler(programHandle, x))
                .OrderBy(z => z.UniformLocation)
                .ToList();

            #if DEBUG
            KrShaderUtils.ValidateProgram (programHandle);
            #endif

            KrShaderUtils.DetachShader(programHandle, fragShaderHandle);
            KrShaderUtils.DetachShader(programHandle, vertShaderHandle);

            KrShaderUtils.DeleteShader(programHandle, fragShaderHandle);
            KrShaderUtils.DeleteShader(programHandle, vertShaderHandle);
        }

        public void Activate ()
        {
            GL.UseProgram (programHandle);
            KrErrorHandler.Check ();
        }

        public void Dispose()
        {
            KrShaderUtils.DestroyShaderProgram(programHandle);
            KrErrorHandler.Check();
        }
    }

