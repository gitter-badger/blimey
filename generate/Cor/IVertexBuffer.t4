    /// <summary>
    /// todo
    /// </summary>
    public interface IVertexBuffer
    {
        /// <summary>
        /// todo
        /// </summary>
        Int32 VertexCount { get; }

        /// <summary>
        /// todo
        /// </summary>
        VertexDeclaration VertexDeclaration { get; }

#if !AOT
        /// <summary>
        /// todo
        /// </summary>
        void SetData<T> (T[] data) where T: struct, IVertexType;

        /// <summary>
        /// todo
        /// </summary>
        //void GetData<T> (T[] data) where T: struct, IVertexType;

        /// <summary>
        /// todo
        /// </summary>
        //void SetData<T> (
        //    T[] data,
        //    Int32 startIndex,
        //    Int32 elementCount)
        //    where T: struct, IVertexType;

        /// <summary>
        /// todo
        /// </summary>
        //void GetData<T> (
        //    T[] data,
        //    Int32 startIndex,
        //    Int32 elementCount)
        //    where T: struct, IVertexType;
        
        /// <summary>
        /// todo
        /// </summary>
        //void SetData<T> (
        //    Int32 offsetInBytes, 
        //    T[] data, 
        //    Int32 startIndex, 
        //    Int32 elementCount, 
        //    Int32 vertexStride) 
        //    where T: struct, IVertexType;
        
        /// <summary>
        /// todo
        /// </summary>
        //void GetData<T> (
        //    Int32 offsetInBytes, 
        //    T[] data, 
        //    Int32 startIndex, 
        //    Int32 elementCount, 
        //    Int32 vertexStride) 
        //    where T: struct, IVertexType;
#else
        /// <summary>
        /// Defines which vertex elements are optionally used by this
        /// shader if they happen to be present.
        /// </summary>
        void SetData (VertexPosition[] data);

        /// <summary>
        /// Defines which vertex elements are optionally used by this
        /// shader if they happen to be present.
        /// </summary>
        void SetData (VertexPositionColour[] data);

        /// <summary>
        /// Defines which vertex elements are optionally used by this
        /// shader if they happen to be present.
        /// </summary>
        void SetData (VertexPositionNormal[] data);

        /// <summary>
        /// Defines which vertex elements are optionally used by this
        /// shader if they happen to be present.
        /// </summary>
        void SetData (VertexPositionNormalColour[] data);

        /// <summary>
        /// Defines which vertex elements are optionally used by this
        /// shader if they happen to be present.
        /// </summary>
        void SetData (VertexPositionNormalTexture[] data);

        /// <summary>
        /// Defines which vertex elements are optionally used by this
        /// shader if they happen to be present.
        /// </summary>
        void SetData (VertexPositionNormalTextureColour[] data);

        /// <summary>
        /// Defines which vertex elements are optionally used by this
        /// shader if they happen to be present.
        /// </summary>
        void SetData (VertexPositionTexture[] data);

        /// <summary>
        /// Defines which vertex elements are optionally used by this
        /// shader if they happen to be present.
        /// </summary>
        void SetData (VertexPositionTextureColour[] data);
#endif
    }

